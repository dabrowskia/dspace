% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/polygon_ds.R
\name{polygon_ds}
\alias{polygon_ds}
\title{polygon_ds}
\usage{
polygon_ds(
  x,
  k = 2,
  queen = T,
  data = 2:ncol(x),
  method = "euclidean",
  style = "B",
  disjoint = F,
  n.neigh = 8,
  plot = T,
  accuracy = T
)
}
\arguments{
\item{x}{point or polygon shapefile data;}

\item{k}{number of clusters;}

\item{data}{atributes of the spatial data frame to calculate similarity or
distance measure;}

\item{method}{Character or function to declare distance method. If method is
character, method must be "mahalanobis" or "euclidean", "maximum",
"manhattan", "canberra", "binary" or "minkowisk". If method is one of
"euclidean", "maximum", "manhattan", "canberra", "binary" or "minkowisk",
see dist for details, because this function as used to compute the distance.
If method="mahalanobis", the mahalanobis distance is computed between
neighbour areas. If method is a function, this function is used to compute
the distance.}

\item{style}{style can take values “W”, “B”, “C”, “U”, “minmax” and “S”}

\item{disjoint}{if default settings generate error occuring to disjoint
subgraphs it means, that in some places points or polygons are to disjoint
to generate one connected graph. Use disjoint = T to enforce that one graph
will be created. This is a slower option.}

\item{n.neigh}{number of neighbours considered in the k-nearest neighbour
algorithm that builds topology}

\item{plot}{should the neighbourhood be plotted}

\item{accuracy}{logical should accuracy be calculated based on randomForest algorithm}
}
\value{
vector of numbers representing regions to whicheach element
}
\description{
Creates a vector of community assignment based on neighbouring polygons. It
creates a topological structure in which nodes represent polygons and the edge
is the similarity between nodes. Communities are created using fast greedy
algorithm that maximizes their modularity.
}
\examples{
 data("World",package = "tmap")
 world<- filter(World,!is.na(World$lifeExp))
 modularity<-find_no_clusters(world,data=c(9,10),disjoint = T,plot=T,n.neigh = 6)
 plot_modularity(modularity)
 world$class<-polygon_ds(world,data=c(9,10),k=7,style="B",disjoint = T,plot=T,n.neigh = 6)
 qtm(world,"class")
}
